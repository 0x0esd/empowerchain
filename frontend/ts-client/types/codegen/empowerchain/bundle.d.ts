import * as _107 from "./accesscontrol/events";
import * as _108 from "./accesscontrol/genesis";
import * as _109 from "./accesscontrol/permission";
import * as _110 from "./plasticcredit/authz";
import * as _111 from "./plasticcredit/events";
import * as _112 from "./plasticcredit/genesis";
import * as _113 from "./plasticcredit/query";
import * as _114 from "./plasticcredit/tx";
import * as _115 from "./plasticcredit/types";
import * as _116 from "./proofofexistence/events";
import * as _117 from "./proofofexistence/genesis";
import * as _118 from "./proofofexistence/query";
import * as _119 from "./proofofexistence/tx";
import * as _120 from "./proofofexistence/types";
import * as _236 from "./plasticcredit/query.lcd";
import * as _237 from "./proofofexistence/query.lcd";
import * as _238 from "./plasticcredit/query.rpc.Query";
import * as _239 from "./proofofexistence/query.rpc.Query";
import * as _240 from "./plasticcredit/tx.rpc.msg";
import * as _241 from "./proofofexistence/tx.rpc.msg";
export declare namespace empowerchain {
    const accesscontrol: {
        Permission: {
            encode(_: _109.Permission, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _109.Permission;
            fromPartial(_: {}): _109.Permission;
        };
        GenesisState: {
            encode(message: _108.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _108.GenesisState;
            fromPartial(object: {
                permStores?: {
                    moduleName?: string;
                    accesses?: {
                        address?: string;
                        msgType?: string;
                    }[];
                }[];
            }): _108.GenesisState;
        };
        ModulePermStore: {
            encode(message: _108.ModulePermStore, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _108.ModulePermStore;
            fromPartial(object: {
                moduleName?: string;
                accesses?: {
                    address?: string;
                    msgType?: string;
                }[];
            }): _108.ModulePermStore;
        };
        Access: {
            encode(message: _108.Access, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _108.Access;
            fromPartial(object: {
                address?: string;
                msgType?: string;
            }): _108.Access;
        };
        EventAccessGranted: {
            encode(message: _107.EventAccessGranted, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _107.EventAccessGranted;
            fromPartial(object: {
                moduleName?: string;
                account?: string;
                msgType?: string;
            }): _107.EventAccessGranted;
        };
        EventAccessRevoked: {
            encode(message: _107.EventAccessRevoked, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _107.EventAccessRevoked;
            fromPartial(object: {
                moduleName?: string;
                account?: string;
                msgType?: string;
            }): _107.EventAccessRevoked;
        };
    };
    const plasticcredit: {
        MsgClientImpl: typeof _240.MsgClientImpl;
        QueryClientImpl: typeof _238.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            params(request?: _113.QueryParamsRequest): Promise<_113.QueryParamsResponse>;
            issuers(request?: _113.QueryIssuersRequest): Promise<_113.QueryIssuersResponse>;
            issuer(request: _113.QueryIssuerRequest): Promise<_113.QueryIssuerResponse>;
            applicants(request?: _113.QueryApplicantsRequest): Promise<_113.QueryApplicantsResponse>;
            applicant(request: _113.QueryApplicantRequest): Promise<_113.QueryApplicantResponse>;
            creditClasses(request?: _113.QueryCreditClassesRequest): Promise<_113.QueryCreditClassesResponse>;
            creditClass(request: _113.QueryCreditClassRequest): Promise<_113.QueryCreditClassResponse>;
            projects(request?: _113.QueryProjectsRequest): Promise<_113.QueryProjectsResponse>;
            project(request: _113.QueryProjectRequest): Promise<_113.QueryProjectResponse>;
            creditCollection(request: _113.QueryCreditCollectionRequest): Promise<_113.QueryCreditCollectionResponse>;
            creditBalances(request?: _113.QueryCreditBalancesRequest): Promise<_113.QueryCreditBalancesResponse>;
            creditBalance(request: _113.QueryCreditBalanceRequest): Promise<_113.QueryCreditBalanceResponse>;
        };
        LCDQueryClient: typeof _236.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                updateParams(value: _114.MsgUpdateParams): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                createIssuer(value: _114.MsgCreateIssuer): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateIssuer(value: _114.MsgUpdateIssuer): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                createApplicant(value: _114.MsgCreateApplicant): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateApplicant(value: _114.MsgUpdateApplicant): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                createCreditClass(value: _114.MsgCreateCreditClass): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateCreditClass(value: _114.MsgUpdateCreditClass): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                createProject(value: _114.MsgCreateProject): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                updateProject(value: _114.MsgUpdateProject): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                approveProject(value: _114.MsgApproveProject): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                rejectProject(value: _114.MsgRejectProject): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                suspendProject(value: _114.MsgSuspendProject): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                issueCredits(value: _114.MsgIssueCredits): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                transferCredits(value: _114.MsgTransferCredits): {
                    typeUrl: string;
                    value: Uint8Array;
                };
                retireCredits(value: _114.MsgRetireCredits): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                updateParams(value: _114.MsgUpdateParams): {
                    typeUrl: string;
                    value: _114.MsgUpdateParams;
                };
                createIssuer(value: _114.MsgCreateIssuer): {
                    typeUrl: string;
                    value: _114.MsgCreateIssuer;
                };
                updateIssuer(value: _114.MsgUpdateIssuer): {
                    typeUrl: string;
                    value: _114.MsgUpdateIssuer;
                };
                createApplicant(value: _114.MsgCreateApplicant): {
                    typeUrl: string;
                    value: _114.MsgCreateApplicant;
                };
                updateApplicant(value: _114.MsgUpdateApplicant): {
                    typeUrl: string;
                    value: _114.MsgUpdateApplicant;
                };
                createCreditClass(value: _114.MsgCreateCreditClass): {
                    typeUrl: string;
                    value: _114.MsgCreateCreditClass;
                };
                updateCreditClass(value: _114.MsgUpdateCreditClass): {
                    typeUrl: string;
                    value: _114.MsgUpdateCreditClass;
                };
                createProject(value: _114.MsgCreateProject): {
                    typeUrl: string;
                    value: _114.MsgCreateProject;
                };
                updateProject(value: _114.MsgUpdateProject): {
                    typeUrl: string;
                    value: _114.MsgUpdateProject;
                };
                approveProject(value: _114.MsgApproveProject): {
                    typeUrl: string;
                    value: _114.MsgApproveProject;
                };
                rejectProject(value: _114.MsgRejectProject): {
                    typeUrl: string;
                    value: _114.MsgRejectProject;
                };
                suspendProject(value: _114.MsgSuspendProject): {
                    typeUrl: string;
                    value: _114.MsgSuspendProject;
                };
                issueCredits(value: _114.MsgIssueCredits): {
                    typeUrl: string;
                    value: _114.MsgIssueCredits;
                };
                transferCredits(value: _114.MsgTransferCredits): {
                    typeUrl: string;
                    value: _114.MsgTransferCredits;
                };
                retireCredits(value: _114.MsgRetireCredits): {
                    typeUrl: string;
                    value: _114.MsgRetireCredits;
                };
            };
            fromPartial: {
                updateParams(value: _114.MsgUpdateParams): {
                    typeUrl: string;
                    value: _114.MsgUpdateParams;
                };
                createIssuer(value: _114.MsgCreateIssuer): {
                    typeUrl: string;
                    value: _114.MsgCreateIssuer;
                };
                updateIssuer(value: _114.MsgUpdateIssuer): {
                    typeUrl: string;
                    value: _114.MsgUpdateIssuer;
                };
                createApplicant(value: _114.MsgCreateApplicant): {
                    typeUrl: string;
                    value: _114.MsgCreateApplicant;
                };
                updateApplicant(value: _114.MsgUpdateApplicant): {
                    typeUrl: string;
                    value: _114.MsgUpdateApplicant;
                };
                createCreditClass(value: _114.MsgCreateCreditClass): {
                    typeUrl: string;
                    value: _114.MsgCreateCreditClass;
                };
                updateCreditClass(value: _114.MsgUpdateCreditClass): {
                    typeUrl: string;
                    value: _114.MsgUpdateCreditClass;
                };
                createProject(value: _114.MsgCreateProject): {
                    typeUrl: string;
                    value: _114.MsgCreateProject;
                };
                updateProject(value: _114.MsgUpdateProject): {
                    typeUrl: string;
                    value: _114.MsgUpdateProject;
                };
                approveProject(value: _114.MsgApproveProject): {
                    typeUrl: string;
                    value: _114.MsgApproveProject;
                };
                rejectProject(value: _114.MsgRejectProject): {
                    typeUrl: string;
                    value: _114.MsgRejectProject;
                };
                suspendProject(value: _114.MsgSuspendProject): {
                    typeUrl: string;
                    value: _114.MsgSuspendProject;
                };
                issueCredits(value: _114.MsgIssueCredits): {
                    typeUrl: string;
                    value: _114.MsgIssueCredits;
                };
                transferCredits(value: _114.MsgTransferCredits): {
                    typeUrl: string;
                    value: _114.MsgTransferCredits;
                };
                retireCredits(value: _114.MsgRetireCredits): {
                    typeUrl: string;
                    value: _114.MsgRetireCredits;
                };
            };
        };
        AminoConverter: {
            "/empowerchain.plasticcredit.MsgUpdateParams": {
                aminoType: string;
                toAmino: ({ authority, params }: _114.MsgUpdateParams) => {
                    authority: string;
                    params: {
                        issuer_creator: string;
                        credit_class_creation_fee: {
                            denom: string;
                            amount: string;
                        };
                    };
                };
                fromAmino: ({ authority, params }: {
                    authority: string;
                    params: {
                        issuer_creator: string;
                        credit_class_creation_fee: {
                            denom: string;
                            amount: string;
                        };
                    };
                }) => _114.MsgUpdateParams;
            };
            "/empowerchain.plasticcredit.MsgCreateIssuer": {
                aminoType: string;
                toAmino: ({ creator, name, description, admin }: _114.MsgCreateIssuer) => {
                    creator: string;
                    name: string;
                    description: string;
                    admin: string;
                };
                fromAmino: ({ creator, name, description, admin }: {
                    creator: string;
                    name: string;
                    description: string;
                    admin: string;
                }) => _114.MsgCreateIssuer;
            };
            "/empowerchain.plasticcredit.MsgUpdateIssuer": {
                aminoType: string;
                toAmino: ({ updater, issuerId, name, description, admin }: _114.MsgUpdateIssuer) => {
                    updater: string;
                    issuer_id: string;
                    name: string;
                    description: string;
                    admin: string;
                };
                fromAmino: ({ updater, issuer_id, name, description, admin }: {
                    updater: string;
                    issuer_id: string;
                    name: string;
                    description: string;
                    admin: string;
                }) => _114.MsgUpdateIssuer;
            };
            "/empowerchain.plasticcredit.MsgCreateApplicant": {
                aminoType: string;
                toAmino: ({ name, description, admin }: _114.MsgCreateApplicant) => {
                    name: string;
                    description: string;
                    admin: string;
                };
                fromAmino: ({ name, description, admin }: {
                    name: string;
                    description: string;
                    admin: string;
                }) => _114.MsgCreateApplicant;
            };
            "/empowerchain.plasticcredit.MsgUpdateApplicant": {
                aminoType: string;
                toAmino: ({ updater, applicantId, name, description, admin }: _114.MsgUpdateApplicant) => {
                    updater: string;
                    applicant_id: string;
                    name: string;
                    description: string;
                    admin: string;
                };
                fromAmino: ({ updater, applicant_id, name, description, admin }: {
                    updater: string;
                    applicant_id: string;
                    name: string;
                    description: string;
                    admin: string;
                }) => _114.MsgUpdateApplicant;
            };
            "/empowerchain.plasticcredit.MsgCreateCreditClass": {
                aminoType: string;
                toAmino: ({ creator, abbreviation, issuerId, name }: _114.MsgCreateCreditClass) => {
                    creator: string;
                    abbreviation: string;
                    issuer_id: string;
                    name: string;
                };
                fromAmino: ({ creator, abbreviation, issuer_id, name }: {
                    creator: string;
                    abbreviation: string;
                    issuer_id: string;
                    name: string;
                }) => _114.MsgCreateCreditClass;
            };
            "/empowerchain.plasticcredit.MsgUpdateCreditClass": {
                aminoType: string;
                toAmino: ({ updater, abbreviation, name }: _114.MsgUpdateCreditClass) => {
                    updater: string;
                    abbreviation: string;
                    name: string;
                };
                fromAmino: ({ updater, abbreviation, name }: {
                    updater: string;
                    abbreviation: string;
                    name: string;
                }) => _114.MsgUpdateCreditClass;
            };
            "/empowerchain.plasticcredit.MsgCreateProject": {
                aminoType: string;
                toAmino: ({ creator, applicantId, creditClassAbbreviation, name }: _114.MsgCreateProject) => {
                    creator: string;
                    applicant_id: string;
                    credit_class_abbreviation: string;
                    name: string;
                };
                fromAmino: ({ creator, applicant_id, credit_class_abbreviation, name }: {
                    creator: string;
                    applicant_id: string;
                    credit_class_abbreviation: string;
                    name: string;
                }) => _114.MsgCreateProject;
            };
            "/empowerchain.plasticcredit.MsgUpdateProject": {
                aminoType: string;
                toAmino: ({ updater, projectId, name }: _114.MsgUpdateProject) => {
                    updater: string;
                    project_id: string;
                    name: string;
                };
                fromAmino: ({ updater, project_id, name }: {
                    updater: string;
                    project_id: string;
                    name: string;
                }) => _114.MsgUpdateProject;
            };
            "/empowerchain.plasticcredit.MsgApproveProject": {
                aminoType: string;
                toAmino: ({ approver, projectId }: _114.MsgApproveProject) => {
                    approver: string;
                    project_id: string;
                };
                fromAmino: ({ approver, project_id }: {
                    approver: string;
                    project_id: string;
                }) => _114.MsgApproveProject;
            };
            "/empowerchain.plasticcredit.MsgRejectProject": {
                aminoType: string;
                toAmino: ({ rejector, projectId }: _114.MsgRejectProject) => {
                    rejector: string;
                    project_id: string;
                };
                fromAmino: ({ rejector, project_id }: {
                    rejector: string;
                    project_id: string;
                }) => _114.MsgRejectProject;
            };
            "/empowerchain.plasticcredit.MsgSuspendProject": {
                aminoType: string;
                toAmino: ({ updater, projectId }: _114.MsgSuspendProject) => {
                    updater: string;
                    project_id: string;
                };
                fromAmino: ({ updater, project_id }: {
                    updater: string;
                    project_id: string;
                }) => _114.MsgSuspendProject;
            };
            "/empowerchain.plasticcredit.MsgIssueCredits": {
                aminoType: string;
                toAmino: ({ creator, projectId, serialNumber, creditAmount }: _114.MsgIssueCredits) => {
                    creator: string;
                    project_id: string;
                    serial_number: string;
                    credit_amount: string;
                };
                fromAmino: ({ creator, project_id, serial_number, credit_amount }: {
                    creator: string;
                    project_id: string;
                    serial_number: string;
                    credit_amount: string;
                }) => _114.MsgIssueCredits;
            };
            "/empowerchain.plasticcredit.MsgTransferCredits": {
                aminoType: string;
                toAmino: ({ from, to, denom, amount, retire }: _114.MsgTransferCredits) => {
                    from: string;
                    to: string;
                    denom: string;
                    amount: string;
                    retire: boolean;
                };
                fromAmino: ({ from, to, denom, amount, retire }: {
                    from: string;
                    to: string;
                    denom: string;
                    amount: string;
                    retire: boolean;
                }) => _114.MsgTransferCredits;
            };
            "/empowerchain.plasticcredit.MsgRetireCredits": {
                aminoType: string;
                toAmino: ({ owner, denom, amount }: _114.MsgRetireCredits) => {
                    owner: string;
                    denom: string;
                    amount: string;
                };
                fromAmino: ({ owner, denom, amount }: {
                    owner: string;
                    denom: string;
                    amount: string;
                }) => _114.MsgRetireCredits;
            };
        };
        projectStatusFromJSON(object: any): _115.ProjectStatus;
        projectStatusToJSON(object: _115.ProjectStatus): string;
        ProjectStatus: typeof _115.ProjectStatus;
        ProjectStatusSDKType: typeof _115.ProjectStatusSDKType;
        Params: {
            encode(message: _115.Params, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.Params;
            fromPartial(object: {
                issuerCreator?: string;
                creditClassCreationFee?: {
                    denom?: string;
                    amount?: string;
                };
            }): _115.Params;
        };
        IDCounters: {
            encode(message: _115.IDCounters, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.IDCounters;
            fromPartial(object: {
                nextIssuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                nextApplicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                nextProjectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _115.IDCounters;
        };
        Issuer: {
            encode(message: _115.Issuer, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.Issuer;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
                description?: string;
                admin?: string;
            }): _115.Issuer;
        };
        Applicant: {
            encode(message: _115.Applicant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.Applicant;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
                description?: string;
                admin?: string;
            }): _115.Applicant;
        };
        CreditClass: {
            encode(message: _115.CreditClass, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.CreditClass;
            fromPartial(object: {
                abbreviation?: string;
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
            }): _115.CreditClass;
        };
        Project: {
            encode(message: _115.Project, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.Project;
            fromPartial(object: {
                id?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creditClassAbbreviation?: string;
                name?: string;
                status?: _115.ProjectStatus;
            }): _115.Project;
        };
        CreditCollection: {
            encode(message: _115.CreditCollection, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.CreditCollection;
            fromPartial(object: {
                denom?: string;
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                totalAmount?: {
                    active?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    retired?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
            }): _115.CreditCollection;
        };
        CreditBalance: {
            encode(message: _115.CreditBalance, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.CreditBalance;
            fromPartial(object: {
                owner?: string;
                denom?: string;
                balance?: {
                    active?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    retired?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
            }): _115.CreditBalance;
        };
        CreditAmount: {
            encode(message: _115.CreditAmount, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.CreditAmount;
            fromPartial(object: {
                active?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                retired?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _115.CreditAmount;
        };
        ProvenData: {
            encode(message: _115.ProvenData, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _115.ProvenData;
            fromPartial(object: {
                uri?: string;
                hash?: string;
            }): _115.ProvenData;
        };
        MsgUpdateParams: {
            encode(message: _114.MsgUpdateParams, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateParams;
            fromPartial(object: {
                authority?: string;
                params?: {
                    issuerCreator?: string;
                    creditClassCreationFee?: {
                        denom?: string;
                        amount?: string;
                    };
                };
            }): _114.MsgUpdateParams;
        };
        MsgUpdateParamsResponse: {
            encode(_: _114.MsgUpdateParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateParamsResponse;
            fromPartial(_: {}): _114.MsgUpdateParamsResponse;
        };
        MsgCreateIssuer: {
            encode(message: _114.MsgCreateIssuer, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateIssuer;
            fromPartial(object: {
                creator?: string;
                name?: string;
                description?: string;
                admin?: string;
            }): _114.MsgCreateIssuer;
        };
        MsgCreateIssuerResponse: {
            encode(message: _114.MsgCreateIssuerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateIssuerResponse;
            fromPartial(object: {
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgCreateIssuerResponse;
        };
        MsgUpdateIssuer: {
            encode(message: _114.MsgUpdateIssuer, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateIssuer;
            fromPartial(object: {
                updater?: string;
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
                description?: string;
                admin?: string;
            }): _114.MsgUpdateIssuer;
        };
        MsgUpdateIssuerResponse: {
            encode(_: _114.MsgUpdateIssuerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateIssuerResponse;
            fromPartial(_: {}): _114.MsgUpdateIssuerResponse;
        };
        MsgCreateApplicant: {
            encode(message: _114.MsgCreateApplicant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateApplicant;
            fromPartial(object: {
                name?: string;
                description?: string;
                admin?: string;
            }): _114.MsgCreateApplicant;
        };
        MsgCreateApplicantResponse: {
            encode(message: _114.MsgCreateApplicantResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateApplicantResponse;
            fromPartial(object: {
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgCreateApplicantResponse;
        };
        MsgUpdateApplicant: {
            encode(message: _114.MsgUpdateApplicant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateApplicant;
            fromPartial(object: {
                updater?: string;
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
                description?: string;
                admin?: string;
            }): _114.MsgUpdateApplicant;
        };
        MsgUpdateApplicantResponse: {
            encode(_: _114.MsgUpdateApplicantResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateApplicantResponse;
            fromPartial(_: {}): _114.MsgUpdateApplicantResponse;
        };
        MsgCreateCreditClass: {
            encode(message: _114.MsgCreateCreditClass, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateCreditClass;
            fromPartial(object: {
                creator?: string;
                abbreviation?: string;
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
            }): _114.MsgCreateCreditClass;
        };
        MsgCreateCreditClassResponse: {
            encode(_: _114.MsgCreateCreditClassResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateCreditClassResponse;
            fromPartial(_: {}): _114.MsgCreateCreditClassResponse;
        };
        MsgUpdateCreditClass: {
            encode(message: _114.MsgUpdateCreditClass, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateCreditClass;
            fromPartial(object: {
                updater?: string;
                abbreviation?: string;
                name?: string;
            }): _114.MsgUpdateCreditClass;
        };
        MsgUpdateCreditClassResponse: {
            encode(_: _114.MsgUpdateCreditClassResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateCreditClassResponse;
            fromPartial(_: {}): _114.MsgUpdateCreditClassResponse;
        };
        MsgCreateProject: {
            encode(message: _114.MsgCreateProject, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateProject;
            fromPartial(object: {
                creator?: string;
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creditClassAbbreviation?: string;
                name?: string;
            }): _114.MsgCreateProject;
        };
        MsgCreateProjectResponse: {
            encode(message: _114.MsgCreateProjectResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgCreateProjectResponse;
            fromPartial(object: {
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgCreateProjectResponse;
        };
        MsgUpdateProject: {
            encode(message: _114.MsgUpdateProject, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateProject;
            fromPartial(object: {
                updater?: string;
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
            }): _114.MsgUpdateProject;
        };
        MsgUpdateProjectResponse: {
            encode(_: _114.MsgUpdateProjectResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgUpdateProjectResponse;
            fromPartial(_: {}): _114.MsgUpdateProjectResponse;
        };
        MsgApproveProject: {
            encode(message: _114.MsgApproveProject, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgApproveProject;
            fromPartial(object: {
                approver?: string;
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgApproveProject;
        };
        MsgApproveProjectResponse: {
            encode(_: _114.MsgApproveProjectResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgApproveProjectResponse;
            fromPartial(_: {}): _114.MsgApproveProjectResponse;
        };
        MsgRejectProject: {
            encode(message: _114.MsgRejectProject, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgRejectProject;
            fromPartial(object: {
                rejector?: string;
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgRejectProject;
        };
        MsgRejectProjectResponse: {
            encode(_: _114.MsgRejectProjectResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgRejectProjectResponse;
            fromPartial(_: {}): _114.MsgRejectProjectResponse;
        };
        MsgSuspendProject: {
            encode(message: _114.MsgSuspendProject, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgSuspendProject;
            fromPartial(object: {
                updater?: string;
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgSuspendProject;
        };
        MsgSuspendProjectResponse: {
            encode(_: _114.MsgSuspendProjectResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgSuspendProjectResponse;
            fromPartial(_: {}): _114.MsgSuspendProjectResponse;
        };
        MsgIssueCredits: {
            encode(message: _114.MsgIssueCredits, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgIssueCredits;
            fromPartial(object: {
                creator?: string;
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                serialNumber?: string;
                creditAmount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgIssueCredits;
        };
        MsgIssueCreditsResponse: {
            encode(message: _114.MsgIssueCreditsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgIssueCreditsResponse;
            fromPartial(object: {
                collection?: {
                    denom?: string;
                    projectId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    totalAmount?: {
                        active?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        retired?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                };
            }): _114.MsgIssueCreditsResponse;
        };
        MsgTransferCredits: {
            encode(message: _114.MsgTransferCredits, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgTransferCredits;
            fromPartial(object: {
                from?: string;
                to?: string;
                denom?: string;
                amount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                retire?: boolean;
            }): _114.MsgTransferCredits;
        };
        MsgTransferCreditsResponse: {
            encode(_: _114.MsgTransferCreditsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgTransferCreditsResponse;
            fromPartial(_: {}): _114.MsgTransferCreditsResponse;
        };
        MsgRetireCredits: {
            encode(message: _114.MsgRetireCredits, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgRetireCredits;
            fromPartial(object: {
                owner?: string;
                denom?: string;
                amount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _114.MsgRetireCredits;
        };
        MsgRetireCreditsResponse: {
            encode(message: _114.MsgRetireCreditsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _114.MsgRetireCreditsResponse;
            fromPartial(object: {
                balance?: {
                    owner?: string;
                    denom?: string;
                    balance?: {
                        active?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        retired?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                };
            }): _114.MsgRetireCreditsResponse;
        };
        QueryParamsRequest: {
            encode(_: _113.QueryParamsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryParamsRequest;
            fromPartial(_: {}): _113.QueryParamsRequest;
        };
        QueryParamsResponse: {
            encode(message: _113.QueryParamsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryParamsResponse;
            fromPartial(object: {
                params?: {
                    issuerCreator?: string;
                    creditClassCreationFee?: {
                        denom?: string;
                        amount?: string;
                    };
                };
            }): _113.QueryParamsResponse;
        };
        QueryIssuersRequest: {
            encode(message: _113.QueryIssuersRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryIssuersRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _113.QueryIssuersRequest;
        };
        QueryIssuersResponse: {
            encode(message: _113.QueryIssuersResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryIssuersResponse;
            fromPartial(object: {
                issuers?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                    description?: string;
                    admin?: string;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
            }): _113.QueryIssuersResponse;
        };
        QueryIssuerRequest: {
            encode(message: _113.QueryIssuerRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryIssuerRequest;
            fromPartial(object: {
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _113.QueryIssuerRequest;
        };
        QueryIssuerResponse: {
            encode(message: _113.QueryIssuerResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryIssuerResponse;
            fromPartial(object: {
                issuer?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                    description?: string;
                    admin?: string;
                };
            }): _113.QueryIssuerResponse;
        };
        QueryApplicantsRequest: {
            encode(message: _113.QueryApplicantsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryApplicantsRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _113.QueryApplicantsRequest;
        };
        QueryApplicantsResponse: {
            encode(message: _113.QueryApplicantsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryApplicantsResponse;
            fromPartial(object: {
                applicants?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                    description?: string;
                    admin?: string;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
            }): _113.QueryApplicantsResponse;
        };
        QueryApplicantRequest: {
            encode(message: _113.QueryApplicantRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryApplicantRequest;
            fromPartial(object: {
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _113.QueryApplicantRequest;
        };
        QueryApplicantResponse: {
            encode(message: _113.QueryApplicantResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryApplicantResponse;
            fromPartial(object: {
                applicant?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                    description?: string;
                    admin?: string;
                };
            }): _113.QueryApplicantResponse;
        };
        QueryCreditClassesRequest: {
            encode(message: _113.QueryCreditClassesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditClassesRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _113.QueryCreditClassesRequest;
        };
        QueryCreditClassesResponse: {
            encode(message: _113.QueryCreditClassesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditClassesResponse;
            fromPartial(object: {
                creditClasses?: {
                    abbreviation?: string;
                    issuerId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
            }): _113.QueryCreditClassesResponse;
        };
        QueryCreditClassRequest: {
            encode(message: _113.QueryCreditClassRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditClassRequest;
            fromPartial(object: {
                creditClassAbbreviation?: string;
            }): _113.QueryCreditClassRequest;
        };
        QueryCreditClassResponse: {
            encode(message: _113.QueryCreditClassResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditClassResponse;
            fromPartial(object: {
                creditClass?: {
                    abbreviation?: string;
                    issuerId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                };
            }): _113.QueryCreditClassResponse;
        };
        QueryProjectsRequest: {
            encode(message: _113.QueryProjectsRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryProjectsRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _113.QueryProjectsRequest;
        };
        QueryProjectsResponse: {
            encode(message: _113.QueryProjectsResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryProjectsResponse;
            fromPartial(object: {
                projects?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    applicantId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    creditClassAbbreviation?: string;
                    name?: string;
                    status?: _115.ProjectStatus;
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
            }): _113.QueryProjectsResponse;
        };
        QueryProjectRequest: {
            encode(message: _113.QueryProjectRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryProjectRequest;
            fromPartial(object: {
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _113.QueryProjectRequest;
        };
        QueryProjectResponse: {
            encode(message: _113.QueryProjectResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryProjectResponse;
            fromPartial(object: {
                project?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    applicantId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    creditClassAbbreviation?: string;
                    name?: string;
                    status?: _115.ProjectStatus;
                };
            }): _113.QueryProjectResponse;
        };
        QueryCreditCollectionRequest: {
            encode(message: _113.QueryCreditCollectionRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditCollectionRequest;
            fromPartial(object: {
                denom?: string;
            }): _113.QueryCreditCollectionRequest;
        };
        QueryCreditCollectionResponse: {
            encode(message: _113.QueryCreditCollectionResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditCollectionResponse;
            fromPartial(object: {
                creditCollection?: {
                    denom?: string;
                    projectId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    totalAmount?: {
                        active?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        retired?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                };
            }): _113.QueryCreditCollectionResponse;
        };
        QueryCreditBalancesRequest: {
            encode(message: _113.QueryCreditBalancesRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditBalancesRequest;
            fromPartial(object: {
                pagination?: {
                    key?: Uint8Array;
                    offset?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    limit?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    countTotal?: boolean;
                    reverse?: boolean;
                };
            }): _113.QueryCreditBalancesRequest;
        };
        QueryCreditBalancesResponse: {
            encode(message: _113.QueryCreditBalancesResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditBalancesResponse;
            fromPartial(object: {
                creditBalances?: {
                    owner?: string;
                    denom?: string;
                    balance?: {
                        active?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        retired?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                }[];
                pagination?: {
                    nextKey?: Uint8Array;
                    total?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
            }): _113.QueryCreditBalancesResponse;
        };
        QueryCreditBalanceRequest: {
            encode(message: _113.QueryCreditBalanceRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditBalanceRequest;
            fromPartial(object: {
                owner?: string;
                denom?: string;
            }): _113.QueryCreditBalanceRequest;
        };
        QueryCreditBalanceResponse: {
            encode(message: _113.QueryCreditBalanceResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _113.QueryCreditBalanceResponse;
            fromPartial(object: {
                balance?: {
                    owner?: string;
                    denom?: string;
                    balance?: {
                        active?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        retired?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                };
            }): _113.QueryCreditBalanceResponse;
        };
        GenesisState: {
            encode(message: _112.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _112.GenesisState;
            fromPartial(object: {
                params?: {
                    issuerCreator?: string;
                    creditClassCreationFee?: {
                        denom?: string;
                        amount?: string;
                    };
                };
                idCounters?: {
                    nextIssuerId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    nextApplicantId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    nextProjectId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                };
                issuers?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                    description?: string;
                    admin?: string;
                }[];
                applicants?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                    description?: string;
                    admin?: string;
                }[];
                creditClasses?: {
                    abbreviation?: string;
                    issuerId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    name?: string;
                }[];
                projects?: {
                    id?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    applicantId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    creditClassAbbreviation?: string;
                    name?: string;
                    status?: _115.ProjectStatus;
                }[];
                creditCollections?: {
                    denom?: string;
                    projectId?: {
                        high?: number;
                        low?: number;
                        unsigned?: boolean;
                        add?: (addend: string | number | import("long")) => import("long");
                        and?: (other: string | number | import("long")) => import("long");
                        compare?: (other: string | number | import("long")) => number;
                        comp?: (other: string | number | import("long")) => number;
                        divide?: (divisor: string | number | import("long")) => import("long");
                        div?: (divisor: string | number | import("long")) => import("long");
                        equals?: (other: string | number | import("long")) => boolean;
                        eq?: (other: string | number | import("long")) => boolean;
                        getHighBits?: () => number;
                        getHighBitsUnsigned?: () => number;
                        getLowBits?: () => number;
                        getLowBitsUnsigned?: () => number;
                        getNumBitsAbs?: () => number;
                        greaterThan?: (other: string | number | import("long")) => boolean;
                        gt?: (other: string | number | import("long")) => boolean;
                        greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                        gte?: (other: string | number | import("long")) => boolean;
                        ge?: (other: string | number | import("long")) => boolean;
                        isEven?: () => boolean;
                        isNegative?: () => boolean;
                        isOdd?: () => boolean;
                        isPositive?: () => boolean;
                        isZero?: () => boolean;
                        eqz?: () => boolean;
                        lessThan?: (other: string | number | import("long")) => boolean;
                        lt?: (other: string | number | import("long")) => boolean;
                        lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                        lte?: (other: string | number | import("long")) => boolean;
                        le?: (other: string | number | import("long")) => boolean;
                        modulo?: (other: string | number | import("long")) => import("long");
                        mod?: (other: string | number | import("long")) => import("long");
                        rem?: (other: string | number | import("long")) => import("long");
                        multiply?: (multiplier: string | number | import("long")) => import("long");
                        mul?: (multiplier: string | number | import("long")) => import("long");
                        negate?: () => import("long");
                        neg?: () => import("long");
                        not?: () => import("long");
                        countLeadingZeros?: () => number;
                        clz?: () => number;
                        countTrailingZeros?: () => number;
                        ctz?: () => number;
                        notEquals?: (other: string | number | import("long")) => boolean;
                        neq?: (other: string | number | import("long")) => boolean;
                        ne?: (other: string | number | import("long")) => boolean;
                        or?: (other: string | number | import("long")) => import("long");
                        shiftLeft?: (numBits: number | import("long")) => import("long");
                        shl?: (numBits: number | import("long")) => import("long");
                        shiftRight?: (numBits: number | import("long")) => import("long");
                        shr?: (numBits: number | import("long")) => import("long");
                        shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                        shru?: (numBits: number | import("long")) => import("long");
                        shr_u?: (numBits: number | import("long")) => import("long");
                        rotateLeft?: (numBits: number | import("long")) => import("long");
                        rotl?: (numBits: number | import("long")) => import("long");
                        rotateRight?: (numBits: number | import("long")) => import("long");
                        rotr?: (numBits: number | import("long")) => import("long");
                        subtract?: (subtrahend: string | number | import("long")) => import("long");
                        sub?: (subtrahend: string | number | import("long")) => import("long");
                        toInt?: () => number;
                        toNumber?: () => number;
                        toBytes?: (le?: boolean) => number[];
                        toBytesLE?: () => number[];
                        toBytesBE?: () => number[];
                        toSigned?: () => import("long");
                        toString?: (radix?: number) => string;
                        toUnsigned?: () => import("long");
                        xor?: (other: string | number | import("long")) => import("long");
                    };
                    totalAmount?: {
                        active?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        retired?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                }[];
                creditBalances?: {
                    owner?: string;
                    denom?: string;
                    balance?: {
                        active?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                        retired?: {
                            high?: number;
                            low?: number;
                            unsigned?: boolean;
                            add?: (addend: string | number | import("long")) => import("long");
                            and?: (other: string | number | import("long")) => import("long");
                            compare?: (other: string | number | import("long")) => number;
                            comp?: (other: string | number | import("long")) => number;
                            divide?: (divisor: string | number | import("long")) => import("long");
                            div?: (divisor: string | number | import("long")) => import("long");
                            equals?: (other: string | number | import("long")) => boolean;
                            eq?: (other: string | number | import("long")) => boolean;
                            getHighBits?: () => number;
                            getHighBitsUnsigned?: () => number;
                            getLowBits?: () => number;
                            getLowBitsUnsigned?: () => number;
                            getNumBitsAbs?: () => number;
                            greaterThan?: (other: string | number | import("long")) => boolean;
                            gt?: (other: string | number | import("long")) => boolean;
                            greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                            gte?: (other: string | number | import("long")) => boolean;
                            ge?: (other: string | number | import("long")) => boolean;
                            isEven?: () => boolean;
                            isNegative?: () => boolean;
                            isOdd?: () => boolean;
                            isPositive?: () => boolean;
                            isZero?: () => boolean;
                            eqz?: () => boolean;
                            lessThan?: (other: string | number | import("long")) => boolean;
                            lt?: (other: string | number | import("long")) => boolean;
                            lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                            lte?: (other: string | number | import("long")) => boolean;
                            le?: (other: string | number | import("long")) => boolean;
                            modulo?: (other: string | number | import("long")) => import("long");
                            mod?: (other: string | number | import("long")) => import("long");
                            rem?: (other: string | number | import("long")) => import("long");
                            multiply?: (multiplier: string | number | import("long")) => import("long");
                            mul?: (multiplier: string | number | import("long")) => import("long");
                            negate?: () => import("long");
                            neg?: () => import("long");
                            not?: () => import("long");
                            countLeadingZeros?: () => number;
                            clz?: () => number;
                            countTrailingZeros?: () => number;
                            ctz?: () => number;
                            notEquals?: (other: string | number | import("long")) => boolean;
                            neq?: (other: string | number | import("long")) => boolean;
                            ne?: (other: string | number | import("long")) => boolean;
                            or?: (other: string | number | import("long")) => import("long");
                            shiftLeft?: (numBits: number | import("long")) => import("long");
                            shl?: (numBits: number | import("long")) => import("long");
                            shiftRight?: (numBits: number | import("long")) => import("long");
                            shr?: (numBits: number | import("long")) => import("long");
                            shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                            shru?: (numBits: number | import("long")) => import("long");
                            shr_u?: (numBits: number | import("long")) => import("long");
                            rotateLeft?: (numBits: number | import("long")) => import("long");
                            rotl?: (numBits: number | import("long")) => import("long");
                            rotateRight?: (numBits: number | import("long")) => import("long");
                            rotr?: (numBits: number | import("long")) => import("long");
                            subtract?: (subtrahend: string | number | import("long")) => import("long");
                            sub?: (subtrahend: string | number | import("long")) => import("long");
                            toInt?: () => number;
                            toNumber?: () => number;
                            toBytes?: (le?: boolean) => number[];
                            toBytesLE?: () => number[];
                            toBytesBE?: () => number[];
                            toSigned?: () => import("long");
                            toString?: (radix?: number) => string;
                            toUnsigned?: () => import("long");
                            xor?: (other: string | number | import("long")) => import("long");
                        };
                    };
                }[];
            }): _112.GenesisState;
        };
        EventCreateIssuer: {
            encode(message: _111.EventCreateIssuer, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventCreateIssuer;
            fromPartial(object: {
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creator?: string;
                name?: string;
                description?: string;
                admin?: string;
            }): _111.EventCreateIssuer;
        };
        EventUpdateIssuer: {
            encode(message: _111.EventUpdateIssuer, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventUpdateIssuer;
            fromPartial(object: {
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creator?: string;
                name?: string;
                description?: string;
                admin?: string;
            }): _111.EventUpdateIssuer;
        };
        EventCreateProject: {
            encode(message: _111.EventCreateProject, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventCreateProject;
            fromPartial(object: {
                creator?: string;
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creditClassAbbreviation?: string;
                name?: string;
            }): _111.EventCreateProject;
        };
        EventUpdateProject: {
            encode(message: _111.EventUpdateProject, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventUpdateProject;
            fromPartial(object: {
                updater?: string;
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
            }): _111.EventUpdateProject;
        };
        EventProjectApproved: {
            encode(message: _111.EventProjectApproved, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventProjectApproved;
            fromPartial(object: {
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                approvedForCreditClassAbbreviation?: string;
                approvingIssuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                approvedBy?: string;
            }): _111.EventProjectApproved;
        };
        EventProjectRejected: {
            encode(message: _111.EventProjectRejected, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventProjectRejected;
            fromPartial(object: {
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                rejectedForCreditClassAbbreviation?: string;
                rejectingIssuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                rejectedBy?: string;
            }): _111.EventProjectRejected;
        };
        EventProjectSuspended: {
            encode(message: _111.EventProjectSuspended, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventProjectSuspended;
            fromPartial(object: {
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                suspendedForCreditClassAbbreviation?: string;
                suspendingIssuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                suspendedBy?: string;
            }): _111.EventProjectSuspended;
        };
        EventIssuedCredits: {
            encode(message: _111.EventIssuedCredits, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventIssuedCredits;
            fromPartial(object: {
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                projectId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creditClassAbbreviation?: string;
                denom?: string;
                amount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                issuerAddress?: string;
            }): _111.EventIssuedCredits;
        };
        EventTransferCredits: {
            encode(message: _111.EventTransferCredits, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventTransferCredits;
            fromPartial(object: {
                sender?: string;
                recipient?: string;
                denom?: string;
                amount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creditClassAbbreviation?: string;
            }): _111.EventTransferCredits;
        };
        EventRetiredCredits: {
            encode(message: _111.EventRetiredCredits, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventRetiredCredits;
            fromPartial(object: {
                owner?: string;
                denom?: string;
                amount?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                creditClassAbbreviation?: string;
            }): _111.EventRetiredCredits;
        };
        EventCreateApplicant: {
            encode(message: _111.EventCreateApplicant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventCreateApplicant;
            fromPartial(object: {
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
                description?: string;
                admin?: string;
            }): _111.EventCreateApplicant;
        };
        EventUpdateApplicant: {
            encode(message: _111.EventUpdateApplicant, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventUpdateApplicant;
            fromPartial(object: {
                applicantId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
                description?: string;
                admin?: string;
                updater?: string;
            }): _111.EventUpdateApplicant;
        };
        EventCreateCreditClass: {
            encode(message: _111.EventCreateCreditClass, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventCreateCreditClass;
            fromPartial(object: {
                creator?: string;
                abbreviation?: string;
                issuerId?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
                name?: string;
            }): _111.EventCreateCreditClass;
        };
        EventUpdateCreditClass: {
            encode(message: _111.EventUpdateCreditClass, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _111.EventUpdateCreditClass;
            fromPartial(object: {
                updater?: string;
                abbreviation?: string;
                name?: string;
            }): _111.EventUpdateCreditClass;
        };
        TransferAuthorization: {
            encode(message: _110.TransferAuthorization, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _110.TransferAuthorization;
            fromPartial(object: {
                denom?: string;
                maxCredits?: {
                    high?: number;
                    low?: number;
                    unsigned?: boolean;
                    add?: (addend: string | number | import("long")) => import("long");
                    and?: (other: string | number | import("long")) => import("long");
                    compare?: (other: string | number | import("long")) => number;
                    comp?: (other: string | number | import("long")) => number;
                    divide?: (divisor: string | number | import("long")) => import("long");
                    div?: (divisor: string | number | import("long")) => import("long");
                    equals?: (other: string | number | import("long")) => boolean;
                    eq?: (other: string | number | import("long")) => boolean;
                    getHighBits?: () => number;
                    getHighBitsUnsigned?: () => number;
                    getLowBits?: () => number;
                    getLowBitsUnsigned?: () => number;
                    getNumBitsAbs?: () => number;
                    greaterThan?: (other: string | number | import("long")) => boolean;
                    gt?: (other: string | number | import("long")) => boolean;
                    greaterThanOrEqual?: (other: string | number | import("long")) => boolean;
                    gte?: (other: string | number | import("long")) => boolean;
                    ge?: (other: string | number | import("long")) => boolean;
                    isEven?: () => boolean;
                    isNegative?: () => boolean;
                    isOdd?: () => boolean;
                    isPositive?: () => boolean;
                    isZero?: () => boolean;
                    eqz?: () => boolean;
                    lessThan?: (other: string | number | import("long")) => boolean;
                    lt?: (other: string | number | import("long")) => boolean;
                    lessThanOrEqual?: (other: string | number | import("long")) => boolean;
                    lte?: (other: string | number | import("long")) => boolean;
                    le?: (other: string | number | import("long")) => boolean;
                    modulo?: (other: string | number | import("long")) => import("long");
                    mod?: (other: string | number | import("long")) => import("long");
                    rem?: (other: string | number | import("long")) => import("long");
                    multiply?: (multiplier: string | number | import("long")) => import("long");
                    mul?: (multiplier: string | number | import("long")) => import("long");
                    negate?: () => import("long");
                    neg?: () => import("long");
                    not?: () => import("long");
                    countLeadingZeros?: () => number;
                    clz?: () => number;
                    countTrailingZeros?: () => number;
                    ctz?: () => number;
                    notEquals?: (other: string | number | import("long")) => boolean;
                    neq?: (other: string | number | import("long")) => boolean;
                    ne?: (other: string | number | import("long")) => boolean;
                    or?: (other: string | number | import("long")) => import("long");
                    shiftLeft?: (numBits: number | import("long")) => import("long");
                    shl?: (numBits: number | import("long")) => import("long");
                    shiftRight?: (numBits: number | import("long")) => import("long");
                    shr?: (numBits: number | import("long")) => import("long");
                    shiftRightUnsigned?: (numBits: number | import("long")) => import("long");
                    shru?: (numBits: number | import("long")) => import("long");
                    shr_u?: (numBits: number | import("long")) => import("long");
                    rotateLeft?: (numBits: number | import("long")) => import("long");
                    rotl?: (numBits: number | import("long")) => import("long");
                    rotateRight?: (numBits: number | import("long")) => import("long");
                    rotr?: (numBits: number | import("long")) => import("long");
                    subtract?: (subtrahend: string | number | import("long")) => import("long");
                    sub?: (subtrahend: string | number | import("long")) => import("long");
                    toInt?: () => number;
                    toNumber?: () => number;
                    toBytes?: (le?: boolean) => number[];
                    toBytesLE?: () => number[];
                    toBytesBE?: () => number[];
                    toSigned?: () => import("long");
                    toString?: (radix?: number) => string;
                    toUnsigned?: () => import("long");
                    xor?: (other: string | number | import("long")) => import("long");
                };
            }): _110.TransferAuthorization;
        };
    };
    const proofofexistence: {
        MsgClientImpl: typeof _241.MsgClientImpl;
        QueryClientImpl: typeof _239.QueryClientImpl;
        createRpcQueryExtension: (base: import("@cosmjs/stargate").QueryClient) => {
            proof(request: _118.QueryProofRequest): Promise<_118.QueryProofResponse>;
        };
        LCDQueryClient: typeof _237.LCDQueryClient;
        registry: readonly [string, import("@cosmjs/proto-signing").GeneratedType][];
        load: (protoRegistry: import("@cosmjs/proto-signing").Registry) => void;
        MessageComposer: {
            encoded: {
                createProof(value: _119.MsgCreateProof): {
                    typeUrl: string;
                    value: Uint8Array;
                };
            };
            withTypeUrl: {
                createProof(value: _119.MsgCreateProof): {
                    typeUrl: string;
                    value: _119.MsgCreateProof;
                };
            };
            fromPartial: {
                createProof(value: _119.MsgCreateProof): {
                    typeUrl: string;
                    value: _119.MsgCreateProof;
                };
            };
        };
        AminoConverter: {
            "/empowerchain.proofofexistence.MsgCreateProof": {
                aminoType: string;
                toAmino: ({ creator, hash }: _119.MsgCreateProof) => {
                    creator: string;
                    hash: string;
                };
                fromAmino: ({ creator, hash }: {
                    creator: string;
                    hash: string;
                }) => _119.MsgCreateProof;
            };
        };
        ProofMetadata: {
            encode(message: _120.ProofMetadata, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _120.ProofMetadata;
            fromPartial(object: {
                timestamp?: Date;
                creator?: string;
            }): _120.ProofMetadata;
        };
        MsgCreateProof: {
            encode(message: _119.MsgCreateProof, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _119.MsgCreateProof;
            fromPartial(object: {
                creator?: string;
                hash?: string;
            }): _119.MsgCreateProof;
        };
        MsgCreateProofResponse: {
            encode(_: _119.MsgCreateProofResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _119.MsgCreateProofResponse;
            fromPartial(_: {}): _119.MsgCreateProofResponse;
        };
        QueryProofRequest: {
            encode(message: _118.QueryProofRequest, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.QueryProofRequest;
            fromPartial(object: {
                hash?: string;
            }): _118.QueryProofRequest;
        };
        QueryProofResponse: {
            encode(message: _118.QueryProofResponse, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _118.QueryProofResponse;
            fromPartial(object: {
                metadata?: {
                    timestamp?: Date;
                    creator?: string;
                };
            }): _118.QueryProofResponse;
        };
        GenesisState: {
            encode(message: _117.GenesisState, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.GenesisState;
            fromPartial(object: {
                proofList?: {
                    hash?: string;
                    metadata?: {
                        timestamp?: Date;
                        creator?: string;
                    };
                }[];
            }): _117.GenesisState;
        };
        Proof: {
            encode(message: _117.Proof, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _117.Proof;
            fromPartial(object: {
                hash?: string;
                metadata?: {
                    timestamp?: Date;
                    creator?: string;
                };
            }): _117.Proof;
        };
        EventCreateProof: {
            encode(message: _116.EventCreateProof, writer?: import("protobufjs").Writer): import("protobufjs").Writer;
            decode(input: Uint8Array | import("protobufjs").Reader, length?: number): _116.EventCreateProof;
            fromPartial(object: {
                hash?: string;
                creator?: string;
            }): _116.EventCreateProof;
        };
    };
    const ClientFactory: {
        createRPCMsgClient: ({ rpc }: {
            rpc: import("../helpers").Rpc;
        }) => Promise<{
            cosmos: {
                auth: {
                    v1beta1: import("../cosmos/auth/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                consensus: {
                    v1: import("../cosmos/consensus/v1/tx.rpc.msg").MsgClientImpl;
                };
                crisis: {
                    v1beta1: import("../cosmos/crisis/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                gov: {
                    v1: import("../cosmos/gov/v1/tx.rpc.msg").MsgClientImpl;
                    v1beta1: import("../cosmos/gov/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                group: {
                    v1: import("../cosmos/group/v1/tx.rpc.msg").MsgClientImpl;
                };
                mint: {
                    v1beta1: import("../cosmos/mint/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                nft: {
                    v1beta1: import("../cosmos/nft/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
                vesting: {
                    v1beta1: import("../cosmos/vesting/v1beta1/tx.rpc.msg").MsgClientImpl;
                };
            };
            empowerchain: {
                plasticcredit: _240.MsgClientImpl;
                proofofexistence: _241.MsgClientImpl;
            };
        }>;
        createRPCQueryClient: ({ rpcEndpoint }: {
            rpcEndpoint: string | import("@cosmjs/tendermint-rpc").HttpEndpoint;
        }) => Promise<{
            cosmos: {
                app: {
                    v1alpha1: {
                        config(request?: import("../cosmos/app/v1alpha1/query").QueryConfigRequest): Promise<import("../cosmos/app/v1alpha1/query").QueryConfigResponse>;
                    };
                };
                auth: {
                    v1beta1: {
                        accounts(request?: import("../cosmos/auth/v1beta1/query").QueryAccountsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountsResponse>;
                        account(request: import("../cosmos/auth/v1beta1/query").QueryAccountRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountResponse>;
                        accountAddressByID(request: import("../cosmos/auth/v1beta1/query").QueryAccountAddressByIDRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountAddressByIDResponse>;
                        params(request?: import("../cosmos/auth/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryParamsResponse>;
                        moduleAccounts(request?: import("../cosmos/auth/v1beta1/query").QueryModuleAccountsRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryModuleAccountsResponse>;
                        moduleAccountByName(request: import("../cosmos/auth/v1beta1/query").QueryModuleAccountByNameRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryModuleAccountByNameResponse>;
                        bech32Prefix(request?: import("../cosmos/auth/v1beta1/query").Bech32PrefixRequest): Promise<import("../cosmos/auth/v1beta1/query").Bech32PrefixResponse>;
                        addressBytesToString(request: import("../cosmos/auth/v1beta1/query").AddressBytesToStringRequest): Promise<import("../cosmos/auth/v1beta1/query").AddressBytesToStringResponse>;
                        addressStringToBytes(request: import("../cosmos/auth/v1beta1/query").AddressStringToBytesRequest): Promise<import("../cosmos/auth/v1beta1/query").AddressStringToBytesResponse>;
                        accountInfo(request: import("../cosmos/auth/v1beta1/query").QueryAccountInfoRequest): Promise<import("../cosmos/auth/v1beta1/query").QueryAccountInfoResponse>;
                    };
                };
                authz: {
                    v1beta1: {
                        grants(request: import("../cosmos/authz/v1beta1/query").QueryGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGrantsResponse>;
                        granterGrants(request: import("../cosmos/authz/v1beta1/query").QueryGranterGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGranterGrantsResponse>;
                        granteeGrants(request: import("../cosmos/authz/v1beta1/query").QueryGranteeGrantsRequest): Promise<import("../cosmos/authz/v1beta1/query").QueryGranteeGrantsResponse>;
                    };
                };
                autocli: {
                    v1: {
                        appOptions(request?: import("../cosmos/autocli/v1/query").AppOptionsRequest): Promise<import("../cosmos/autocli/v1/query").AppOptionsResponse>;
                    };
                };
                bank: {
                    v1beta1: {
                        balance(request: import("../cosmos/bank/v1beta1/query").QueryBalanceRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryBalanceResponse>;
                        allBalances(request: import("../cosmos/bank/v1beta1/query").QueryAllBalancesRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryAllBalancesResponse>;
                        spendableBalances(request: import("../cosmos/bank/v1beta1/query").QuerySpendableBalancesRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySpendableBalancesResponse>;
                        spendableBalanceByDenom(request: import("../cosmos/bank/v1beta1/query").QuerySpendableBalanceByDenomRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySpendableBalanceByDenomResponse>;
                        totalSupply(request?: import("../cosmos/bank/v1beta1/query").QueryTotalSupplyRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryTotalSupplyResponse>;
                        supplyOf(request: import("../cosmos/bank/v1beta1/query").QuerySupplyOfRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySupplyOfResponse>;
                        params(request?: import("../cosmos/bank/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryParamsResponse>;
                        denomMetadata(request: import("../cosmos/bank/v1beta1/query").QueryDenomMetadataRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomMetadataResponse>;
                        denomsMetadata(request?: import("../cosmos/bank/v1beta1/query").QueryDenomsMetadataRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomsMetadataResponse>;
                        denomOwners(request: import("../cosmos/bank/v1beta1/query").QueryDenomOwnersRequest): Promise<import("../cosmos/bank/v1beta1/query").QueryDenomOwnersResponse>;
                        sendEnabled(request: import("../cosmos/bank/v1beta1/query").QuerySendEnabledRequest): Promise<import("../cosmos/bank/v1beta1/query").QuerySendEnabledResponse>;
                    };
                };
                base: {
                    node: {
                        v1beta1: {
                            config(request?: import("../cosmos/base/node/v1beta1/query").ConfigRequest): Promise<import("../cosmos/base/node/v1beta1/query").ConfigResponse>;
                        };
                    };
                    tendermint: {
                        v1beta1: {
                            getNodeInfo(request?: import("../cosmos/base/tendermint/v1beta1/query").GetNodeInfoRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetNodeInfoResponse>;
                            getSyncing(request?: import("../cosmos/base/tendermint/v1beta1/query").GetSyncingRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetSyncingResponse>;
                            getLatestBlock(request?: import("../cosmos/base/tendermint/v1beta1/query").GetLatestBlockRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetLatestBlockResponse>;
                            getBlockByHeight(request: import("../cosmos/base/tendermint/v1beta1/query").GetBlockByHeightRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetBlockByHeightResponse>;
                            getLatestValidatorSet(request?: import("../cosmos/base/tendermint/v1beta1/query").GetLatestValidatorSetRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetLatestValidatorSetResponse>;
                            getValidatorSetByHeight(request: import("../cosmos/base/tendermint/v1beta1/query").GetValidatorSetByHeightRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").GetValidatorSetByHeightResponse>;
                            aBCIQuery(request: import("../cosmos/base/tendermint/v1beta1/query").ABCIQueryRequest): Promise<import("../cosmos/base/tendermint/v1beta1/query").ABCIQueryResponse>;
                        };
                    };
                };
                consensus: {
                    v1: {
                        params(request?: import("../cosmos/consensus/v1/query").QueryParamsRequest): Promise<import("../cosmos/consensus/v1/query").QueryParamsResponse>;
                    };
                };
                distribution: {
                    v1beta1: {
                        params(request?: import("../cosmos/distribution/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryParamsResponse>;
                        validatorDistributionInfo(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorDistributionInfoRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorDistributionInfoResponse>;
                        validatorOutstandingRewards(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorOutstandingRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorOutstandingRewardsResponse>;
                        validatorCommission(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorCommissionRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorCommissionResponse>;
                        validatorSlashes(request: import("../cosmos/distribution/v1beta1/query").QueryValidatorSlashesRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryValidatorSlashesResponse>;
                        delegationRewards(request: import("../cosmos/distribution/v1beta1/query").QueryDelegationRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegationRewardsResponse>;
                        delegationTotalRewards(request: import("../cosmos/distribution/v1beta1/query").QueryDelegationTotalRewardsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegationTotalRewardsResponse>;
                        delegatorValidators(request: import("../cosmos/distribution/v1beta1/query").QueryDelegatorValidatorsRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegatorValidatorsResponse>;
                        delegatorWithdrawAddress(request: import("../cosmos/distribution/v1beta1/query").QueryDelegatorWithdrawAddressRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryDelegatorWithdrawAddressResponse>;
                        communityPool(request?: import("../cosmos/distribution/v1beta1/query").QueryCommunityPoolRequest): Promise<import("../cosmos/distribution/v1beta1/query").QueryCommunityPoolResponse>;
                    };
                };
                evidence: {
                    v1beta1: {
                        evidence(request: import("../cosmos/evidence/v1beta1/query").QueryEvidenceRequest): Promise<import("../cosmos/evidence/v1beta1/query").QueryEvidenceResponse>;
                        allEvidence(request?: import("../cosmos/evidence/v1beta1/query").QueryAllEvidenceRequest): Promise<import("../cosmos/evidence/v1beta1/query").QueryAllEvidenceResponse>;
                    };
                };
                feegrant: {
                    v1beta1: {
                        allowance(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowanceRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowanceResponse>;
                        allowances(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowancesRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowancesResponse>;
                        allowancesByGranter(request: import("../cosmos/feegrant/v1beta1/query").QueryAllowancesByGranterRequest): Promise<import("../cosmos/feegrant/v1beta1/query").QueryAllowancesByGranterResponse>;
                    };
                };
                gov: {
                    v1: {
                        proposal(request: import("../cosmos/gov/v1/query").QueryProposalRequest): Promise<import("../cosmos/gov/v1/query").QueryProposalResponse>;
                        proposals(request: import("../cosmos/gov/v1/query").QueryProposalsRequest): Promise<import("../cosmos/gov/v1/query").QueryProposalsResponse>;
                        vote(request: import("../cosmos/gov/v1/query").QueryVoteRequest): Promise<import("../cosmos/gov/v1/query").QueryVoteResponse>;
                        votes(request: import("../cosmos/gov/v1/query").QueryVotesRequest): Promise<import("../cosmos/gov/v1/query").QueryVotesResponse>;
                        params(request: import("../cosmos/gov/v1/query").QueryParamsRequest): Promise<import("../cosmos/gov/v1/query").QueryParamsResponse>;
                        deposit(request: import("../cosmos/gov/v1/query").QueryDepositRequest): Promise<import("../cosmos/gov/v1/query").QueryDepositResponse>;
                        deposits(request: import("../cosmos/gov/v1/query").QueryDepositsRequest): Promise<import("../cosmos/gov/v1/query").QueryDepositsResponse>;
                        tallyResult(request: import("../cosmos/gov/v1/query").QueryTallyResultRequest): Promise<import("../cosmos/gov/v1/query").QueryTallyResultResponse>;
                    };
                    v1beta1: {
                        proposal(request: import("../cosmos/gov/v1beta1/query").QueryProposalRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryProposalResponse>;
                        proposals(request: import("../cosmos/gov/v1beta1/query").QueryProposalsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryProposalsResponse>;
                        vote(request: import("../cosmos/gov/v1beta1/query").QueryVoteRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryVoteResponse>;
                        votes(request: import("../cosmos/gov/v1beta1/query").QueryVotesRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryVotesResponse>;
                        params(request: import("../cosmos/gov/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryParamsResponse>;
                        deposit(request: import("../cosmos/gov/v1beta1/query").QueryDepositRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryDepositResponse>;
                        deposits(request: import("../cosmos/gov/v1beta1/query").QueryDepositsRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryDepositsResponse>;
                        tallyResult(request: import("../cosmos/gov/v1beta1/query").QueryTallyResultRequest): Promise<import("../cosmos/gov/v1beta1/query").QueryTallyResultResponse>;
                    };
                };
                group: {
                    v1: {
                        groupInfo(request: import("../cosmos/group/v1/query").QueryGroupInfoRequest): Promise<import("../cosmos/group/v1/query").QueryGroupInfoResponse>;
                        groupPolicyInfo(request: import("../cosmos/group/v1/query").QueryGroupPolicyInfoRequest): Promise<import("../cosmos/group/v1/query").QueryGroupPolicyInfoResponse>;
                        groupMembers(request: import("../cosmos/group/v1/query").QueryGroupMembersRequest): Promise<import("../cosmos/group/v1/query").QueryGroupMembersResponse>;
                        groupsByAdmin(request: import("../cosmos/group/v1/query").QueryGroupsByAdminRequest): Promise<import("../cosmos/group/v1/query").QueryGroupsByAdminResponse>;
                        groupPoliciesByGroup(request: import("../cosmos/group/v1/query").QueryGroupPoliciesByGroupRequest): Promise<import("../cosmos/group/v1/query").QueryGroupPoliciesByGroupResponse>;
                        groupPoliciesByAdmin(request: import("../cosmos/group/v1/query").QueryGroupPoliciesByAdminRequest): Promise<import("../cosmos/group/v1/query").QueryGroupPoliciesByAdminResponse>;
                        proposal(request: import("../cosmos/group/v1/query").QueryProposalRequest): Promise<import("../cosmos/group/v1/query").QueryProposalResponse>;
                        proposalsByGroupPolicy(request: import("../cosmos/group/v1/query").QueryProposalsByGroupPolicyRequest): Promise<import("../cosmos/group/v1/query").QueryProposalsByGroupPolicyResponse>;
                        voteByProposalVoter(request: import("../cosmos/group/v1/query").QueryVoteByProposalVoterRequest): Promise<import("../cosmos/group/v1/query").QueryVoteByProposalVoterResponse>;
                        votesByProposal(request: import("../cosmos/group/v1/query").QueryVotesByProposalRequest): Promise<import("../cosmos/group/v1/query").QueryVotesByProposalResponse>;
                        votesByVoter(request: import("../cosmos/group/v1/query").QueryVotesByVoterRequest): Promise<import("../cosmos/group/v1/query").QueryVotesByVoterResponse>;
                        groupsByMember(request: import("../cosmos/group/v1/query").QueryGroupsByMemberRequest): Promise<import("../cosmos/group/v1/query").QueryGroupsByMemberResponse>;
                        tallyResult(request: import("../cosmos/group/v1/query").QueryTallyResultRequest): Promise<import("../cosmos/group/v1/query").QueryTallyResultResponse>;
                    };
                };
                mint: {
                    v1beta1: {
                        params(request?: import("../cosmos/mint/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryParamsResponse>;
                        inflation(request?: import("../cosmos/mint/v1beta1/query").QueryInflationRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryInflationResponse>;
                        annualProvisions(request?: import("../cosmos/mint/v1beta1/query").QueryAnnualProvisionsRequest): Promise<import("../cosmos/mint/v1beta1/query").QueryAnnualProvisionsResponse>;
                    };
                };
                nft: {
                    v1beta1: {
                        balance(request: import("../cosmos/nft/v1beta1/query").QueryBalanceRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryBalanceResponse>;
                        owner(request: import("../cosmos/nft/v1beta1/query").QueryOwnerRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryOwnerResponse>;
                        supply(request: import("../cosmos/nft/v1beta1/query").QuerySupplyRequest): Promise<import("../cosmos/nft/v1beta1/query").QuerySupplyResponse>;
                        nFTs(request: import("../cosmos/nft/v1beta1/query").QueryNFTsRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryNFTsResponse>;
                        nFT(request: import("../cosmos/nft/v1beta1/query").QueryNFTRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryNFTResponse>;
                        class(request: import("../cosmos/nft/v1beta1/query").QueryClassRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryClassResponse>;
                        classes(request?: import("../cosmos/nft/v1beta1/query").QueryClassesRequest): Promise<import("../cosmos/nft/v1beta1/query").QueryClassesResponse>;
                    };
                };
                orm: {
                    query: {
                        v1alpha1: {
                            get(request: import("../cosmos/orm/query/v1alpha1/query").GetRequest): Promise<import("../cosmos/orm/query/v1alpha1/query").GetResponse>;
                            list(request: import("../cosmos/orm/query/v1alpha1/query").ListRequest): Promise<import("../cosmos/orm/query/v1alpha1/query").ListResponse>;
                        };
                    };
                };
                params: {
                    v1beta1: {
                        params(request: import("../cosmos/params/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/params/v1beta1/query").QueryParamsResponse>;
                        subspaces(request?: import("../cosmos/params/v1beta1/query").QuerySubspacesRequest): Promise<import("../cosmos/params/v1beta1/query").QuerySubspacesResponse>;
                    };
                };
                slashing: {
                    v1beta1: {
                        params(request?: import("../cosmos/slashing/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/slashing/v1beta1/query").QueryParamsResponse>;
                        signingInfo(request: import("../cosmos/slashing/v1beta1/query").QuerySigningInfoRequest): Promise<import("../cosmos/slashing/v1beta1/query").QuerySigningInfoResponse>;
                        signingInfos(request?: import("../cosmos/slashing/v1beta1/query").QuerySigningInfosRequest): Promise<import("../cosmos/slashing/v1beta1/query").QuerySigningInfosResponse>;
                    };
                };
                staking: {
                    v1beta1: {
                        validators(request: import("../cosmos/staking/v1beta1/query").QueryValidatorsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorsResponse>;
                        validator(request: import("../cosmos/staking/v1beta1/query").QueryValidatorRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorResponse>;
                        validatorDelegations(request: import("../cosmos/staking/v1beta1/query").QueryValidatorDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorDelegationsResponse>;
                        validatorUnbondingDelegations(request: import("../cosmos/staking/v1beta1/query").QueryValidatorUnbondingDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryValidatorUnbondingDelegationsResponse>;
                        delegation(request: import("../cosmos/staking/v1beta1/query").QueryDelegationRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegationResponse>;
                        unbondingDelegation(request: import("../cosmos/staking/v1beta1/query").QueryUnbondingDelegationRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryUnbondingDelegationResponse>;
                        delegatorDelegations(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorDelegationsResponse>;
                        delegatorUnbondingDelegations(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorUnbondingDelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorUnbondingDelegationsResponse>;
                        redelegations(request: import("../cosmos/staking/v1beta1/query").QueryRedelegationsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryRedelegationsResponse>;
                        delegatorValidators(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorsResponse>;
                        delegatorValidator(request: import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryDelegatorValidatorResponse>;
                        historicalInfo(request: import("../cosmos/staking/v1beta1/query").QueryHistoricalInfoRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryHistoricalInfoResponse>;
                        pool(request?: import("../cosmos/staking/v1beta1/query").QueryPoolRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryPoolResponse>;
                        params(request?: import("../cosmos/staking/v1beta1/query").QueryParamsRequest): Promise<import("../cosmos/staking/v1beta1/query").QueryParamsResponse>;
                    };
                };
                tx: {
                    v1beta1: {
                        simulate(request: import("../cosmos/tx/v1beta1/service").SimulateRequest): Promise<import("../cosmos/tx/v1beta1/service").SimulateResponse>;
                        getTx(request: import("../cosmos/tx/v1beta1/service").GetTxRequest): Promise<import("../cosmos/tx/v1beta1/service").GetTxResponse>;
                        broadcastTx(request: import("../cosmos/tx/v1beta1/service").BroadcastTxRequest): Promise<import("../cosmos/tx/v1beta1/service").BroadcastTxResponse>;
                        getTxsEvent(request: import("../cosmos/tx/v1beta1/service").GetTxsEventRequest): Promise<import("../cosmos/tx/v1beta1/service").GetTxsEventResponse>;
                        getBlockWithTxs(request: import("../cosmos/tx/v1beta1/service").GetBlockWithTxsRequest): Promise<import("../cosmos/tx/v1beta1/service").GetBlockWithTxsResponse>;
                        txDecode(request: import("../cosmos/tx/v1beta1/service").TxDecodeRequest): Promise<import("../cosmos/tx/v1beta1/service").TxDecodeResponse>;
                        txEncode(request: import("../cosmos/tx/v1beta1/service").TxEncodeRequest): Promise<import("../cosmos/tx/v1beta1/service").TxEncodeResponse>;
                        txEncodeAmino(request: import("../cosmos/tx/v1beta1/service").TxEncodeAminoRequest): Promise<import("../cosmos/tx/v1beta1/service").TxEncodeAminoResponse>;
                        txDecodeAmino(request: import("../cosmos/tx/v1beta1/service").TxDecodeAminoRequest): Promise<import("../cosmos/tx/v1beta1/service").TxDecodeAminoResponse>;
                    };
                };
                upgrade: {
                    v1beta1: {
                        currentPlan(request?: import("../cosmos/upgrade/v1beta1/query").QueryCurrentPlanRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryCurrentPlanResponse>;
                        appliedPlan(request: import("../cosmos/upgrade/v1beta1/query").QueryAppliedPlanRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryAppliedPlanResponse>;
                        upgradedConsensusState(request: import("../cosmos/upgrade/v1beta1/query").QueryUpgradedConsensusStateRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryUpgradedConsensusStateResponse>;
                        moduleVersions(request: import("../cosmos/upgrade/v1beta1/query").QueryModuleVersionsRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryModuleVersionsResponse>;
                        authority(request?: import("../cosmos/upgrade/v1beta1/query").QueryAuthorityRequest): Promise<import("../cosmos/upgrade/v1beta1/query").QueryAuthorityResponse>;
                    };
                };
            };
            empowerchain: {
                plasticcredit: {
                    params(request?: _113.QueryParamsRequest): Promise<_113.QueryParamsResponse>;
                    issuers(request?: _113.QueryIssuersRequest): Promise<_113.QueryIssuersResponse>;
                    issuer(request: _113.QueryIssuerRequest): Promise<_113.QueryIssuerResponse>;
                    applicants(request?: _113.QueryApplicantsRequest): Promise<_113.QueryApplicantsResponse>;
                    applicant(request: _113.QueryApplicantRequest): Promise<_113.QueryApplicantResponse>;
                    creditClasses(request?: _113.QueryCreditClassesRequest): Promise<_113.QueryCreditClassesResponse>;
                    creditClass(request: _113.QueryCreditClassRequest): Promise<_113.QueryCreditClassResponse>;
                    projects(request?: _113.QueryProjectsRequest): Promise<_113.QueryProjectsResponse>;
                    project(request: _113.QueryProjectRequest): Promise<_113.QueryProjectResponse>;
                    creditCollection(request: _113.QueryCreditCollectionRequest): Promise<_113.QueryCreditCollectionResponse>;
                    creditBalances(request?: _113.QueryCreditBalancesRequest): Promise<_113.QueryCreditBalancesResponse>;
                    creditBalance(request: _113.QueryCreditBalanceRequest): Promise<_113.QueryCreditBalanceResponse>;
                };
                proofofexistence: {
                    proof(request: _118.QueryProofRequest): Promise<_118.QueryProofResponse>;
                };
            };
        }>;
        createLCDClient: ({ restEndpoint }: {
            restEndpoint: string;
        }) => Promise<{
            cosmos: {
                auth: {
                    v1beta1: import("../cosmos/auth/v1beta1/query.lcd").LCDQueryClient;
                };
                authz: {
                    v1beta1: import("../cosmos/authz/v1beta1/query.lcd").LCDQueryClient;
                };
                bank: {
                    v1beta1: import("../cosmos/bank/v1beta1/query.lcd").LCDQueryClient;
                };
                base: {
                    node: {
                        v1beta1: import("../cosmos/base/node/v1beta1/query.lcd").LCDQueryClient;
                    };
                    tendermint: {
                        v1beta1: import("../cosmos/base/tendermint/v1beta1/query.lcd").LCDQueryClient;
                    };
                };
                consensus: {
                    v1: import("../cosmos/consensus/v1/query.lcd").LCDQueryClient;
                };
                distribution: {
                    v1beta1: import("../cosmos/distribution/v1beta1/query.lcd").LCDQueryClient;
                };
                evidence: {
                    v1beta1: import("../cosmos/evidence/v1beta1/query.lcd").LCDQueryClient;
                };
                feegrant: {
                    v1beta1: import("../cosmos/feegrant/v1beta1/query.lcd").LCDQueryClient;
                };
                gov: {
                    v1: import("../cosmos/gov/v1/query.lcd").LCDQueryClient;
                    v1beta1: import("../cosmos/gov/v1beta1/query.lcd").LCDQueryClient;
                };
                group: {
                    v1: import("../cosmos/group/v1/query.lcd").LCDQueryClient;
                };
                mint: {
                    v1beta1: import("../cosmos/mint/v1beta1/query.lcd").LCDQueryClient;
                };
                nft: {
                    v1beta1: import("../cosmos/nft/v1beta1/query.lcd").LCDQueryClient;
                };
                params: {
                    v1beta1: import("../cosmos/params/v1beta1/query.lcd").LCDQueryClient;
                };
                slashing: {
                    v1beta1: import("../cosmos/slashing/v1beta1/query.lcd").LCDQueryClient;
                };
                staking: {
                    v1beta1: import("../cosmos/staking/v1beta1/query.lcd").LCDQueryClient;
                };
                tx: {
                    v1beta1: import("../cosmos/tx/v1beta1/service.lcd").LCDQueryClient;
                };
                upgrade: {
                    v1beta1: import("../cosmos/upgrade/v1beta1/query.lcd").LCDQueryClient;
                };
            };
            empowerchain: {
                plasticcredit: _236.LCDQueryClient;
                proofofexistence: _237.LCDQueryClient;
            };
        }>;
    };
}
